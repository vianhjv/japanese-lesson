<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Học tiếng Nhật cùng An : Nghe, nói kaiwa</title>
    
<style>
        /* --- Thiết lập cơ bản --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6; margin: 0;  background-color: #f3eadc; 
           }
        .page-header, .page-footer { text-align: center; padding: 20px; }

        /* --- Cấu trúc khung cảnh --- */
        .scene-container {
            max-width: 900px;
            margin: 20px auto;
            position: relative; /* Để canh chỉnh overlay */
        }

        .scene-background-image {
            display: block; 
            width: 100%;
            height: auto;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* CSS RESPONSIVE */
        .dialogue-overlay {
            position: relative; 
            z-index: 10;
            /* Điều chỉnh margin âm để đè lên ảnh một cách hợp lý */
            margin-top: -80px; 
            margin-left: 20px;
            margin-right: 20px;
            padding: 25px;
         background: rgba(200, 180, 140, 0.55); /* Nền sáng hơn, ít trong suốt hơn để dễ đọc */
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.58);
           
        }
        
        @media (max-width: 600px) {
            .dialogue-overlay {
                margin-top: -40px; /* Ít đè lên hơn trên mobile */
                margin-left: 10px;
                margin-right: 10px;
                padding: 15px;
            }
        }

        .dialogue-display-window {
            color: #333;
            text-align: left;
            min-height: 100px; /* Đảm bảo khung không bị nhảy khi đổi nội dung dài ngắn */
            display: flex;
            flex-direction: column;
        }
        
        /* Style cho các thành phần nội dung hội thoại */
        .speaker-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            
        }

        .speaker { font-weight: 800; font-size: 1.1rem; margin-right: 10px;}
        /* Màu sắc đại diện cho nhân vật */
        .speaker.suzuki { color: #e67e22; } /* Cam */
        .speaker.tanaka { color: #2980b9; } /* Xanh dương */
        .speaker.an { color: #e84393; } /* Hồng đậm */
        
        .dialogue-content-wrapper {
            display: flex;
            align-items: flex-start; /* Căn hàng trên cùng */
            gap: 15px;
        }

        .dialogue-play-btn { 
            background-color: #228B22; /* Nút màu xanh lá chủ đạo */
            border: none; 
            width: 40px; height: 40px; border-radius: 50%;
            font-size: 1.2rem; cursor: pointer; 
            color: white; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .dialogue-play-btn:hover { background-color: #1e7a1e; transform: scale(1.05); }
        .dialogue-play-btn:active { transform: scale(0.95); }

        .dialogue-texts { flex-grow: 1; }
        
        .japanese-text {
           font-size: clamp(1.2rem, 4vw, 1.6rem); /* Tăng kích thước font tiếng Nhật */
            line-height: 1.8;
            margin: 0 0 8px 0;
            color: #2c3e50;
            font-weight: 500;
        }
        
        /* Tối ưu Furigana */
        ruby { ruby-align: center;}
        rt { font-size: 0.6em; color: #7f8c8d; user-select: none; } 

        .vietnamese-text {
            font-size: 1rem;
            color: #555; 
            margin-top: 0;
            font-style: normal;
            border-left: 3px solid #228B22;
            padding-left: 10px;
        }

        /* Highlight khi đọc */
        .highlight-word {  
            background-color: #fffa90; 
            border-radius: 4px; 
            box-shadow: 0 0 0 1px #f1c40f; /* Viền nhẹ */
        }

        /* Ngữ pháp nổi bật */
        .grammar-point {
            color: #c0392b; 
            font-weight: bold;
            border-bottom: 2px dotted #c0392b; /* Gạch chân chấm bi */
        }

        /* Bảng điều khiển */
        .dialogue-nav { 
            display: flex; justify-content: center; align-items: center; gap: 20px;
            margin-top: 20px; padding-top: 15px;
        }
        #counter { color: #777; font-weight: 500; min-width: 50px; text-align: center; }
        
        .nav-btn { 
            background-color: white; border: 1px solid #ccc; color: #333; 
            padding: 8px 20px; border-radius: 20px; cursor: pointer; transition: all 0.2s ease; 
            font-weight: 500; display: flex; align-items: center; gap: 5px;
        }
        .nav-btn:hover:not(:disabled) { background-color: #f9f9f9; border-color: #999; }
        .nav-btn:disabled { opacity: 0.5; cursor: default; background-color: #f0f0f0; border-color: #ddd;}

    </style>
</head>
<body>

    <div class="page-header">
        <h2>Nói Kaiwa cùng An</h2>
        <p>Luyện Nghe, Nói, Ngữ pháp, Từ vựng thi JLPT</p>
    </div>

    <div class="scene-container">
        <img src="lesson1-chat.jpg" alt="Minh họa hội thoại" class="scene-background-image">

        <div class="dialogue-overlay">
            
            <!-- Khung hiển thị -->
            <div class="dialogue-display-window"></div>

            <!-- Nguồn dữ liệu (Ẩn) -->
            <div class="dialogue-source" style="display: none;">
                
                <!-- Line 1 -->
                <div class="dialogue-line">
                    <div class="speaker-container">
                        <span class="speaker suzuki" data-character="suzuki">鈴木 (Suzuki)</span>
                    </div>
                    <div class="dialogue-content-wrapper">
                        <button class="dialogue-play-btn" aria-label="Nghe">🔊</button>
                        <div class="dialogue-texts">
                            <p class="japanese-text"><ruby>田中<rt>たなか</rt></ruby>さん、<ruby>週末<rt>しゅうまつ</rt></ruby>は<ruby>何<rt>なに</rt></ruby>をするの？</p>
                            <p class="vietnamese-text">Anh Tanaka, cuối tuần anh làm gì thế?</p>
                        </div>
                    </div>
                </div>

                <!-- Line 2 -->
                <div class="dialogue-line">
                    <div class="speaker-container">
                        <!-- Tôi gán Tanaka dùng giọng Keita nếu có, hoặc Ichiro -->
                        <span class="speaker tanaka" data-character="tanaka">田中 (Tanaka)</span>
                    </div>
                    <div class="dialogue-content-wrapper">
                        <button class="dialogue-play-btn" aria-label="Nghe">🔊</button>
                        <div class="dialogue-texts">
                            <p class="japanese-text">うーん、まだ<ruby>決<rt>き</rt></ruby>めてないけど、<ruby>家<rt>いえ</rt></ruby>で<ruby>本<rt>ほん</rt></ruby>を <span class="grammar-point"><ruby>読<rt>よ</rt></ruby>んで</span>、<ruby>音楽<rt>おんがく</rt></ruby>を <span class="grammar-point"><ruby>聞<rt>き</rt></ruby>いて</span>、ゆっくりするかな。</p>
                            <p class="vietnamese-text">Ừm, tôi chưa quyết định nữa, nhưng chắc là sẽ đọc sách, nghe nhạc ở nhà và thư giãn thôi.</p>
                        </div>
                    </div>
                </div>

                <!-- Line 3 -->
                <div class="dialogue-line">
                    <div class="speaker-container">
                        <span class="speaker suzuki" data-character="suzuki">鈴木 (Suzuki)</span>
                    </div>
                    <div class="dialogue-content-wrapper">
                        <button class="dialogue-play-btn" aria-label="Nghe">🔊</button>
                        <div class="dialogue-texts">
                            <p class="japanese-text"><ruby>私<rt>わたし</rt></ruby>は<ruby>友達<rt>ともだち</rt></ruby>に <span class="grammar-point"><ruby>会<rt>あ</rt></ruby>って</span>、<ruby>一緒<rt>いっしょ</rt></ruby>にご<ruby>飯<rt>はん</rt></ruby>を <span class="grammar-point"><ruby>食<rt>た</rt></ruby>べる</span>つもり。アンさんは？</p>
                            <p class="vietnamese-text">Hay nhỉ. Tôi thì định gặp bạn rồi cùng nhau ăn cơm. Còn An thì sao?</p>
                        </div>
                    </div>
                </div>

                <!-- Line 4 -->
                 <div class="dialogue-line">
                    <div class="speaker-container">
                        <span class="speaker an" data-character="an">アン (An)</span>
                    </div>
                    <div class="dialogue-content-wrapper">
                        <button class="dialogue-play-btn" aria-label="Nghe">🔊</button>
                        <div class="dialogue-texts">
                            <p class="japanese-text"><ruby>私<rt>わたし</rt></ruby>は<ruby>日本語<rt>にほんご</rt></ruby>を<span class="grammar-point"><ruby>勉強<rt>べんきょう</rt></ruby>します</span>！でも...「<span class="grammar-point"><ruby>読<rt>よ</rt></ruby>んで</span>」、「<span class="grammar-point"><ruby>聞<rt>き</rt></ruby>いて</span>」、「<span class="grammar-point"><ruby>会<rt>あ</rt></ruby>って</span>」...<ruby>動詞<rt>どうし</rt></ruby>は<ruby>面白<rt>おもしろ</rt></ruby>いですが、<ruby>少<rt>すこ</rt></ruby>し<ruby>混乱<rt>こんらん</rt></ruby>します。</p>
                            <p class="vietnamese-text">Em sẽ học tiếng Nhật ạ! Nhưng mà... "yonde", "kiite", "atte"... động từ thú vị thật nhưng em hơi bị rối.</p>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Điều hướng -->
            <div class="dialogue-nav">
                <button id="prevBtn" class="nav-btn" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/></svg>
                    Lùi
                </button>
                <span id="counter">1 / 4</span>
                <button id="nextBtn" class="nav-btn">
                    Tiếp
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg>
                </button>
            </div>
        </div>
    </div>

    <div class="page-footer">
        <p>Phần nội dung tiếp theo của bài học...</p>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // =================================================================
    // === PHẦN 0: BỘ QUẢN LÝ GIỌNG ĐỌC (NÂNG CẤP ƯU TIÊN MICROSOFT) ===
    // =================================================================
    const voiceManager = {
        characterMap: {},
        defaultVoice: null,
        voicesLoaded: false,

        // Cấu hình giọng ưu tiên (keyword để tìm trong tên giọng)
        preferences: {
            'an': 'nanami',      // Ưu tiên Nanami cho An
            'suzuki': 'haruka',  // Ưu tiên Haruka cho Suzuki
            'mio': 'haruka',     // Ưu tiên Haruka cho Mio
            'sato': 'sayaka',    // Ưu tiên Sayaka cho Sato-sensei
            'yamada': 'daichi',  // Ưu tiên Daichi cho Yamada-bucho
            'tanaka': 'keita'    // Ưu tiên Keita (hoặc Ichiro) cho Tanaka
        },

        init: function() {
            // Thử tải giọng ngay lập tức
            this.loadVoices();
            
            // Chrome/Edge cần sự kiện này để tải danh sách giọng đầy đủ
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = () => this.loadVoices();
            }
        },

        loadVoices: function() {
            if (this.voicesLoaded) return; // Tránh chạy lại nhiều lần không cần thiết

            const allVoices = speechSynthesis.getVoices();
            if (allVoices.length === 0) return; // Chưa có giọng nào

            // Lọc giọng tiếng Nhật
            const japaneseVoices = allVoices.filter(v => v.lang === 'ja-JP' || v.lang === 'ja_JP');

            if (japaneseVoices.length === 0) {
                console.warn("Không tìm thấy giọng tiếng Nhật.");
                this.voicesLoaded = true;
                return;
            }

            this.defaultVoice = japaneseVoices[0];

            // 1. Tìm các giọng CỤ THỂ theo yêu cầu (Microsoft voices)
            const foundPrefVoices = {};
            japaneseVoices.forEach(voice => {
                const voiceNameLower = voice.name.toLowerCase();
                // Kiểm tra xem giọng này có khớp với từ khóa ưu tiên nào không
                for (const [prefKey, prefKeyword] of Object.entries(this.preferences)) {
                    if (voiceNameLower.includes(prefKeyword)) {
                        foundPrefVoices[prefKeyword] = voice;
                    }
                }
            });

            console.log("Tìm thấy các giọng ưu tiên:", Object.keys(foundPrefVoices));

            // 2. Tạo danh sách dự phòng (Fallback) phân loại Nam/Nữ chung chung
            // Sử dụng regex để đoán giới tính qua tên phổ biến
            const femaleGenerics = japaneseVoices.filter(v => /nanami|haruka|sayaka|ayumi|kyoko|mio/i.test(v.name));
            const maleGenerics = japaneseVoices.filter(v => /ichiro|keita|otoya|kenji|daisuke/i.test(v.name));

            // Hàm trợ giúp để lấy giọng: Ưu tiên -> Dự phòng theo giới tính -> Mặc định
            const assignVoice = (charId, genderList, fallbackIndex) => {
                const prefKeyword = this.preferences[charId];
                // Tầng 1: Nếu có giọng ưu tiên cụ thể
                if (foundPrefVoices[prefKeyword]) {
                    return foundPrefVoices[prefKeyword];
                }
                // Tầng 2: Dùng danh sách dự phòng theo giới tính
                if (genderList.length > 0) {
                    return genderList[fallbackIndex % genderList.length];
                }
                // Tầng 3: Giọng mặc định
                return this.defaultVoice;
            };

            // 3. Thực hiện gán giọng cuối cùng
            this.characterMap = {
                'an': assignVoice('an', femaleGenerics, 0),
                'suzuki': assignVoice('suzuki', femaleGenerics, 1),
                'sato': assignVoice('sato', femaleGenerics, 2),
                'mio': assignVoice('mio', femaleGenerics, 1), // Dùng chung logic dự phòng với Suzuki
                'yamada': assignVoice('yamada', maleGenerics, 0),
                'tanaka': assignVoice('tanaka', maleGenerics, 1),
            };

            console.log("Bản đồ giọng đọc cuối cùng:", 
                Object.fromEntries(Object.entries(this.characterMap).map(([k, v]) => [k, v.name]))
            );
            
            this.voicesLoaded = true;
            
            // Nếu đang ở slide đầu tiên, tải lại để áp dụng giọng (phòng trường hợp voices load chậm)
            if (typeof activateSpeechForCurrentLine === 'function') {
                activateSpeechForCurrentLine();
            }
        },

        getVoiceFor: function(characterName) {
            if (!this.voicesLoaded) this.loadVoices(); // Cố gắng tải lại nếu chưa có
            return this.characterMap[characterName] || this.defaultVoice;
        }
    };

    voiceManager.init();


    // =================================================================
    // === PHẦN 1: BỘ MÁY ĐỌC VÀ HIGHLIGHT (Giữ nguyên logic tốt)    ===
    // =================================================================
    let currentSpeechHandler = null;
    
    function createSpeechHandler(targetElement, characterName) {
        // Lưu HTML gốc (bao gồm thẻ ruby/rt)
        let originalHTML = targetElement.innerHTML;
        let charMap = []; 
        let plainText = '';
        let utterance = null;
        let isPlaying = false;
        let isPaused = false;

        // Hàm chuẩn bị: Tách từng ký tự để highlight, nhưng giữ nguyên cấu trúc Ruby
        function _prepareForSpeech() {
            plainText = '';
            charMap = [];
            
            // Tạo bản sao để thao tác, tránh ảnh hưởng DOM hiện tại ngay lập tức
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalHTML;

            function processNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent;
                    plainText += text;
                    const fragment = document.createDocumentFragment();
                    for (const char of text) {
                        const span = document.createElement('span');
                        span.textContent = char;
                        fragment.appendChild(span);
                        charMap.push(span); // Lưu tham chiếu span vào mảng
                    }
                    node.parentNode.replaceChild(fragment, node);
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // Bỏ qua nội dung trong thẻ <rt> (furigana) khi lấy plainText đọc
                    if (node.tagName === 'RT') return;
                    
                    // Duyệt đệ quy các node con (chuyển thành mảng để tránh lỗi live collection)
                    Array.from(node.childNodes).forEach(processNode);
                }
            }

            processNode(tempDiv);
            // Cập nhật lại DOM thật với các thẻ span đã bọc
            targetElement.innerHTML = tempDiv.innerHTML;
            
            // Cập nhật lại tham chiếu charMap tới các span thực tế trong DOM mới
            const allSpans = targetElement.querySelectorAll('span:not(.grammar-point)');
            let spanIndex = 0;
            // Logic này hơi phức tạp để map lại span trong tempDiv với DOM thật
            // Cách đơn giản hơn là clear charMap và tìm lại span không có class
            charMap = Array.from(targetElement.querySelectorAll('span')).filter(s => !s.classList.contains('grammar-point'));
        }

        function _cleanup() {
            // Khôi phục HTML gốc (xóa các thẻ span highlight)
            targetElement.innerHTML = originalHTML;
            isPlaying = false;
            isPaused = false;
            const btn = displayWindow.querySelector('.dialogue-play-btn');
            if(btn) btn.innerHTML = '🔊'; // Reset icon
        }

        function play() {
            // Dừng audio khác đang chạy
            if (currentSpeechHandler && currentSpeechHandler !== this) {
                currentSpeechHandler.stop();
            }
            currentSpeechHandler = this;
            const btn = displayWindow.querySelector('.dialogue-play-btn');

            // Xử lý Resume
            if (isPlaying && isPaused) {
                speechSynthesis.resume();
                isPaused = false;
                if(btn) btn.innerHTML = '⏸';
                return;
            }
            
            // Xử lý Pause
            if (isPlaying && !isPaused) {
                speechSynthesis.pause();
                isPaused = true;
                if(btn) btn.innerHTML = '▶';
                return;
            }
            
            // Bắt đầu đọc mới
            speechSynthesis.cancel(); // Hủy các hàng đợi cũ
            
            // Chuẩn bị DOM (bọc span)
            _prepareForSpeech();
            isPlaying = true;
            isPaused = false;
            if(btn) btn.innerHTML = '⏸';
            
            utterance = new SpeechSynthesisUtterance(plainText);
            utterance.lang = 'ja-JP';
            utterance.rate = 1; // Đọc chậm hơn một chút cho người học (tùy chọn)

            // Lấy giọng từ voiceManager
            const assignedVoice = voiceManager.getVoiceFor(characterName);
            if (assignedVoice) {
                utterance.voice = assignedVoice;
            }

            utterance.onboundary = (event) => {
                if (event.name !== 'word') return;
                
                // Xóa highlight cũ
                const highlighted = targetElement.querySelectorAll('.highlight-word');
                highlighted.forEach(el => el.classList.remove('highlight-word'));

                // Highlight từ mới
                for (let i = 0; i < event.charLength; i++) {
                    const charIndex = event.charIndex + i;
                    if (charMap[charIndex]) {
                        charMap[charIndex].classList.add('highlight-word');
                    }
                }
            };

            utterance.onend = () => {
                _cleanup();
                currentSpeechHandler = null;
            };
            
            utterance.onerror = (event) => {
                console.error('Lỗi đọc:', event);
                _cleanup();
                currentSpeechHandler = null;
            };
            
            speechSynthesis.speak(utterance);
        }

        function stop() {
            if(isPlaying || isPaused) {
                speechSynthesis.cancel();
                _cleanup();
                currentSpeechHandler = null;
            }
        }

        return { play, stop, get isPlaying() { return isPlaying; } };
    }

    // =================================================================
    // === PHẦN 2: ĐIỀU KHIỂN HỘI THOẠI (SLIDESHOW)                  ===
    // =================================================================
    const displayWindow = document.querySelector('.dialogue-display-window');
    const sourceLines = document.querySelectorAll('.dialogue-source .dialogue-line');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const counter = document.getElementById('counter');
    
    let currentIndex = 0;
    const totalLines = sourceLines.length;
    let currentLineHandler = null;

    // Đưa hàm này ra scope ngoài để voiceManager có thể gọi khi load xong giọng
    window.activateSpeechForCurrentLine = function() {
        if (currentLineHandler) {
            currentLineHandler.stop();
        }
        
        const currentPlayBtn = displayWindow.querySelector('.dialogue-play-btn');
        const currentTextElement = displayWindow.querySelector('.japanese-text');
        const currentSpeakerElement = displayWindow.querySelector('.speaker');

        if (currentPlayBtn && currentTextElement && currentSpeakerElement) {
            const characterName = currentSpeakerElement.dataset.character;
            currentLineHandler = createSpeechHandler(currentTextElement, characterName);
            
            // Xóa event listener cũ (bằng cách clone nút) để tránh double click
            const newBtn = currentPlayBtn.cloneNode(true);
            currentPlayBtn.parentNode.replaceChild(newBtn, currentPlayBtn);
            
            newBtn.addEventListener('click', () => {
                currentLineHandler.play();
            });
        }
    }

    function showLine(index) {
        if (index >= 0 && index < totalLines) {
            // Fade out nhẹ (tùy chọn, nếu muốn mượt hơn)
            displayWindow.style.opacity = 0;
            
            setTimeout(() => {
                if (currentLineHandler) currentLineHandler.stop();
                displayWindow.innerHTML = sourceLines[index].innerHTML;
                window.activateSpeechForCurrentLine(); 
                counter.textContent = `${index + 1} / ${totalLines}`;
                
                updateNavButtons();
                displayWindow.style.opacity = 1; // Fade in
            }, 150); // Thời gian khớp với transition CSS
        }
    }
    
    // Thêm transition cho opacity vào CSS của .dialogue-display-window
    displayWindow.style.transition = 'opacity 0.15s ease';

    function updateNavButtons() {
        prevBtn.disabled = (currentIndex === 0);
        nextBtn.disabled = (currentIndex === totalLines - 1);
    }

    nextBtn.addEventListener('click', () => {
        if (currentIndex < totalLines - 1) {
            currentIndex++;
            showLine(currentIndex);
        }
    });

    prevBtn.addEventListener('click', () => {
        if (currentIndex > 0) {
            currentIndex--;
            showLine(currentIndex);
        }
    });

    // Khởi chạy
    if (totalLines > 0) {
        showLine(0);
    }
});
</script>
</body>
</html>
